//+build gtt43 !levis

package display

import (
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/dumacp/matrixorbital/gtt43a"
)

var dayActual int = -1
var minActual int = -1
var statePuerta1 int = 0
var statePuerta2 int = 0
var timeoutRead time.Duration = 1 * time.Second

type touchDisplay struct {
	dev          gtt43a.Display
	screenActual int
	scratchData  []byte
}

const (
	textCivica       int = 25
	textEfectivo     int = 27
	labelParcial     int = 5
	textParcial      int = 9
	usosSliceValue   int = 3
	labelError       int = 20
	labelTextInput   int = 29
	tittleRuta       int = 2
	textRuta         int = 1
	buttonEnter      int = 18
	buttonUp         int = 19
	buttonSelectPaso int = 15
	buttonEnterPaso  int = 16
	buttonRecorrido  int = 10
	buttonCounter    int = 6
	buttonGrid1      int = 0
	buttonGrid2      int = 3
	buttonGrid3      int = 6
	buttonGrid4      int = 1
	buttonGrid5      int = 4
	buttonGrid6      int = 7
	buttonGrid7      int = 2
	buttonGrid8      int = 5
	buttonGrid9      int = 8
	buttonGrid0      int = 10
	buttonGridEnter  int = 11
	buttonGridDel    int = 9
	timeRecorrido    int = 17
	timeHour         int = 24
	timeDate         int = 28
	textBoxError     int = 20

	addrNameRoute    int = 1
	addrPercent      int = 5
	addrConfirmation int = 32

	addrEfectivoCounter int = 3
	addrTotalCounter    int = 4
)

func NewDisplay(m interface{}) (Display, error) {

	dev, ok := m.(gtt43a.Display)
	if !ok {
		return nil, fmt.Errorf("device is not GTT43 device")
	}
	display := &touchDisplay{}
	display.dev = dev
	return display, nil
}

func (m *touchDisplay) screen() int {
	return m.screenActual
}

func (m *touchDisplay) close() {
	m.dev.Close()
}

func (m *touchDisplay) route(routes string) error {

	text := m.dev.SetPropertyText(addrNameRoute,
		gtt43a.LabelText)

	if err := text(routes); err != nil {
		return err
	}

	return nil

}

func (m *touchDisplay) screenError(sError ...string) {

	m.switchScreen(3)
	go func() {
		for i := 0; i < 3; i++ {
			m.dev.BuzzerActive(240, 500)
			time.Sleep(1 * time.Second)
		}
	}()
	text := m.dev.SetPropertyText(int(addrConfirmation), gtt43a.LabelText)
	s1 := ""
	for _, v := range sError {
		s1 = fmt.Sprintf("%s%s\n", s1, v)
	}

	if len(s1) > 0 {
		text(s1[:len(s1)-1])
	}
}

func (m *touchDisplay) textError(sError ...string) {
	if m.screenActual != 3 {
		m.dev.AnimationStopAll()
		m.dev.AnimationSetFrame(0, 0)
		m.dev.AnimationSetFrame(1, 0)
	}
	m.switchScreen(3)
	go func() {
		for i := 0; i < 3; i++ {
			m.dev.BuzzerActive(240, 500)
			time.Sleep(1 * time.Second)
		}
	}()
	text := m.dev.SetPropertyText(int(labelError), gtt43a.LabelText)
	s1 := ""
	for _, v := range sError {
		s1 = fmt.Sprintf("%s%s\n", s1, v)
	}

	if len(s1) > 0 {
		text(s1[:len(s1)-1])
	}
	//m.dev.Version()
}

func (m *touchDisplay) ingresos(usosEfectivo, usosCivica, usosParcial int) {
	/**/
	// textUsosCivica := m.dev.SetPropertyText(int(add), gtt43a.LabelText)
	textUsosEfectivo := m.dev.SetPropertyText(int(textEfectivo), gtt43a.LabelText)
	textUsosCivica(fmt.Sprintf("%d", usosCivica))
	textUsosEfectivo(fmt.Sprintf("%d", usosEfectivo))
	textUsosParcial := m.dev.SetPropertyText(int(textParcial), gtt43a.LabelText)
	textSlice := m.dev.SetPropertyText(int(usosSliceValue), gtt43a.SliderLabelText)

	valueSlice := m.dev.SetPropertyValueS16(int(usosSliceValue), gtt43a.SliderValue)
	if usosEfectivo+usosCivica <= 0 {
		valueSlice(0)
		textSlice(fmt.Sprintf("%d%s", 0, "%"))
	} else {
		valueSlice(usosCivica * 100 / (usosCivica + usosEfectivo))
		textSlice(fmt.Sprintf("%d%s", usosCivica*100/(usosCivica+usosEfectivo), "%"))
	}

	textUsosParcial(fmt.Sprintf("%d", usosParcial))
	/**

		textSlice := ""
		valueSlice := 0
		if usosEfectivo + usosCivica <= 0 {
	                valueSlice = 0
	                textSlice = fmt.Sprintf("%d%s",0,"%")
	        } else {
	                valueSlice = usosCivica*100/(usosCivica + usosEfectivo)
	                textSlice = fmt.Sprintf("%d%s",usosCivica*100/(usosCivica + usosEfectivo), "%")
	        }

		apduTextSlice := gtt43a.ApduSetPropertyText(int(usosSliceValue), gtt43a.SliderLabelText, textSlice)
		apduValueSlice := gtt43a.ApduSetPropertyValueS16(int(usosSliceValue), gtt43a.SliderValue, valueSlice)

		textUsosCivica := gtt43a.ApduSetPropertyText(int(textCivica), gtt43a.LabelText, fmt.Sprintf("%d", usosCivica))
		textUsosParcial := gtt43a.ApduSetPropertyText(int(textParcial), gtt43a.LabelText, fmt.Sprintf("%d", usosParcial))
		textUsosEfectivo := gtt43a.ApduSetPropertyText(int(textEfectivo), gtt43a.LabelText, fmt.Sprintf("%d", usosEfectivo))
		data := make([]byte,0)
		data = append(data, apduTextSlice...)
		data = append(data, apduValueSlice...)
		data = append(data, textUsosCivica...)
		data = append(data, textUsosEfectivo...)
		data = append(data, textUsosParcial...)
		m.dev.Send(data)
		time.Sleep(300 * time.Millisecond)
		m.dev.SendRecvCmd(0x00, nil)
		/**/
}

func (m *touchDisplay) ingresosPartial(usosParcial int) {
	textUsosParcial := m.dev.SetPropertyText(int(textParcial), gtt43a.LabelText)
	textUsosParcial(fmt.Sprintf("%d", usosParcial))
}

func (m *touchDisplay) timeRecorrido(timeLapse int) {
	textRecorrido := m.dev.SetPropertyText(int(timeRecorrido), gtt43a.LabelText)
	textRecorrido(fmt.Sprintf("%d min", timeLapse))
}

func (m *touchDisplay) selectionRuta() {
	// 	label := m.dev.SetPropertyText(int(tittleRuta), gtt43a.LabelText)
	// 	text := m.dev.SetPropertyText(int(textRuta), gtt43a.LabelText)
	// exitFor2:
	// 	for {
	// 		select {
	// 		case ruta := <-chRuta:
	// 			label("Ruta:")
	// 			text(ruta)
	// 		case subruta := <-chSubRuta:
	// 			label("sub\nRuta:")
	// 			text(subruta)
	// 		case <-chSelRuta:
	// 			break exitFor2
	// 		}
	// 	}
	fmt.Println("salir de SELECCION ruta GTT")
}

func (m *touchDisplay) updateRuta(ruta, subruta string) {
	label := m.dev.SetPropertyText(int(tittleRuta), gtt43a.LabelText)
	text := m.dev.SetPropertyText(int(textRuta), gtt43a.LabelText)
	if len(ruta) <= 0 && len(subruta) > 0 {
		label("sub\nRuta:")
		text(subruta)
	} else {
		label("Ruta:")
		text(ruta)
		if len(subruta) > 0 {
			if len(ruta) > 0 {
				text(fmt.Sprintf("%s\n%s", ruta, subruta))
			} else {
				text(ruta)
			}
		}
	}
}

func (m *touchDisplay) alertBeep(repeat int) {
	for i := 0; i < repeat; i++ {
		m.dev.BuzzerActive(1000, 150)
		time.Sleep(time.Millisecond * 400)
	}
}

func (m *touchDisplay) init() {
	m.dev.Listen()
	log.Printf("LISTEN 1\n")
	time.Sleep(3 * time.Second)
	log.Printf("LISTEN 2\n")
	m.updateDate(-1)
	log.Printf("LISTEN 3\n")
	m.timeRecorrido(0)
	m.ingresos(0, 7, 7)
	sizeFont1 := m.dev.SetPropertyValueU16(int(textParcial), gtt43a.LabelFontSize)
	sizeFont1(12)
	m.scratchData = []byte{0x01, 0x10, 0x0A, 0xA0, 0x0B, 0xB0}
	m.dev.WriteScratch(1, m.scratchData)

}

func (m *touchDisplay) verifyReset() chan int {
	ch := make(chan int)
	/**/
	go func() {
		defer close(ch)
		tick := time.NewTicker(time.Second * 10)
		defer tick.Stop()
		for {
			//log.Printf("memory scratchData: [% X]\n", m.scratchData)
			select {
			case <-tick.C:
				scratchpad, err := m.dev.ReadScratch(1, len(m.scratchData))
				if err != nil {
					log.Println(err)
					continue
				}
				log.Printf("now scratchData: [% X]\n", scratchpad)
				if len(scratchpad) < len(m.scratchData) {
					m.screenActual = 0
					ch <- 1
					continue
				}
				for i, b := range scratchpad {
					if b != m.scratchData[i] {
						m.screenActual = 0
						ch <- 1
						break
					}
				}
			}
		}
		log.Println("verifyReset stop")
	}()
	/**/
	return ch
}

func (m *touchDisplay) switchScreen(screen int) {
	/**/
	if m.screenActual == screen {
		return
	}
	/**/
	m.dev.RunScript(fmt.Sprintf("GTTProject1\\Screen%d\\Screen%d.bin", screen, screen))
	m.screenActual = screen
}

func (m *touchDisplay) mainScreen() {
	m.switchScreen(2)
	// m.setPuerta(LEDPuerta1, statePuerta1)
	// m.setPuerta(LEDPuerta2, statePuerta2)
	time.Sleep(time.Millisecond * 800)
	m.dev.Version()
}

func (m *touchDisplay) disableSelectButton() {
	setState := m.dev.SetPropertyValueU8(int(buttonSelectPaso), gtt43a.ButtonState)
	setState(0x00)
}

func (m *touchDisplay) updateDate(period int) {
	tNow := time.Now()
	//log.Printf("UpdateDate: %d", tNow.Minute())
	//log.Printf("UpdateDate: %d", tNow.UnixNano())
	if period <= 0 || tNow.Minute() != minActual {
		textTime := m.dev.SetPropertyText(int(timeHour), gtt43a.LabelText)
		textTime(tNow.Format("15:04"))
		minActual = tNow.Minute()
		if tNow.Day() != dayActual || period <= 0 {
			textDate := m.dev.SetPropertyText(int(timeDate), gtt43a.LabelText)
			textDate(tNow.Format("2/01/2006"))
			dayActual = tNow.Day()
		}
	}
}

func (m *touchDisplay) reset() {
	m.dev.Reset()
}

func (m *touchDisplay) setPuerta(id, state int) {
	if state == 0 {
		m.dev.AnimationSetFrame(id, 0)
	}
	// if id == LEDPuerta1 {
	// 	statePuerta1 = state
	// }
	// if id == LEDPuerta2 {
	// 	statePuerta2 = state
	// }

	m.dev.AnimationStartStop(id, state)
}

func (m *touchDisplay) textInput(stext ...string) {
	if m.screenActual < 3 {
		log.Println("STOP animation")
		m.dev.AnimationStopAll()
		// m.dev.AnimationSetFrame(LEDPuerta1, 0)
		// m.dev.AnimationSetFrame(LEDPuerta2, 0)
	}
	m.switchScreen(4)
	text := m.dev.SetPropertyText(int(labelTextInput), gtt43a.LabelText)
	s1 := ""
	for _, v := range stext {
		s1 = fmt.Sprintf("%s%s\n", s1, v)
	}

	if len(s1) > 0 {
		text(s1[:len(s1)-1])
	}
	//m.dev.Version()
}

var cacheTextInput string = ""

func (m *touchDisplay) addTextInput(schar string) {
	cacheTextInput = strings.Join([]string{cacheTextInput, schar}, "")
	log.Printf("cacheTextInput: %s", cacheTextInput)
	m.textInput(cacheTextInput)
}

func (m *touchDisplay) delTextInput(count int) {
	if len(cacheTextInput) > count {
		cacheTextInput = cacheTextInput[0 : len(cacheTextInput)-count]
	} else {
		cacheTextInput = ""
	}
	m.textInput(cacheTextInput)
}

func (m *touchDisplay) clearTextInput() {
	m.textInput("")
}

func (m *touchDisplay) doors(value [2]int) error {

	return nil
}

func (m *touchDisplay) recorridoPercent(value int) error {
	valuefunc := m.dev.SetPropertyValueS16(addrPercent, gtt43a.SliderValue)

	if err := valuefunc(value); err != nil {
		return err
	}

	return nil
}
